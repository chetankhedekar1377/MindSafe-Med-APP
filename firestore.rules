/**
 * Core Philosophy: This ruleset enforces a strict, private, user-ownership model for user-specific data, while allowing anonymous writes to a public collection for triage sessions.
 *
 * Data Structure: The data model is split. User-specific data is nested under `/users/{userId}`. Anonymous, public data for triage sessions is in a top-level `triageSessions` collection.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is only granted through explicit `allow` statements.
 * - Anonymous Writes for Triage: Anyone can create a document in `/triageSessions`. This is essential for the anonymous symptom triage feature. Updates are allowed to add feedback later. Reads and deletes are disallowed to protect the aggregated anonymous data.
 * - Private User Data: The `/users/{userId}` path and all its subcollections are strictly private and can only be accessed by the authenticated owner.
 *
 * Denormalization for Authorization: For the private user data, the structure inherently supports this principle. By placing a user's private data under their unique ID, we can write simple, fast, and secure rules without needing to read other documents for authorization context.
 *
 * Structural Segregation: The model segregates private user data from public anonymous data. This is crucial for security. The `triageSessions` collection has a homogeneous security posture (write-only for anonymous users), and the `/users` collection has its own strict, private posture.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isUserIdConsistent(userId) {
      return request.resource.data.id == userId;
    }

    function isUserIdImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    function isAuthorizingFieldValid(userId) {
      return request.resource.data.userId == userId;
    }

    function isAuthorizingFieldImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Anonymous Triage Data Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to anonymous triage sessions.
     * @path /triageSessions/{sessionId}
     * @allow (create) Any user (authenticated or anonymous) can create a new triage session document. This is critical for the main feature.
     * @allow (update) Any user can update a session, specifically to add feedback later. The document fields themselves are secured by the application logic.
     * @deny (get, list, delete) No one can read or delete session data from the client-side to protect the integrity of the anonymized dataset.
     * @principle Allows for anonymous data collection for the triage feature while protecting the dataset from being read or tampered with.
     */
    match /triageSessions/{sessionId} {
      allow get, list, delete: if false;
      allow create, update: if true; // Allow anyone to create and update (for feedback)
    }

    // ------------------------------------------------------------------------
    // Private User Data Rules
    // ------------------------------------------------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && isUserIdConsistent(userId);
      allow update: if isExistingOwner(userId) && isUserIdImmutable();
      allow delete: if isExistingOwner(userId);

      match /symptomLogs/{symptomLogId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && isAuthorizingFieldValid(userId);
        allow update: if isExistingOwner(userId) && isAuthorizingFieldImmutable();
        allow delete: if isExistingOwner(userId);
      }

      match /medications/{medicationId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && isAuthorizingFieldValid(userId);
        allow update: if isExistingOwner(userId) && isAuthorizingFieldImmutable();
        allow delete: if isExistingOwner(userId);
      }

      match /medicationReminders/{medicationReminderId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
      
      match /healthInsights/{healthInsightId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && isAuthorizingFieldValid(userId);
        allow update: if isExistingOwner(userId) && isAuthorizingFieldImmutable();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}
